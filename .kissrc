#!/bin/bash
unset kiss ssh_random_string allocate_port run_checks init deploy install_plugin php_exec
case $- in
  *i*) export bash_interactive=1;;
esac

if [[ "$PROJECT" ]]; then
  if [[ "$bash_interactive" ]]; then
    HISTFILE=$HOME/.${PROJECT}_history
    PS1="\[\033[1;31m\]\$PROJECT\[\033[0m\] $ps1_backup"
  fi
else
  export path_backup="$PATH";
  export ps1_backup="$PS1";
fi

kiss() {
  if [[ "$PROJECT" ]]; then
    cd $HOME/$PROJECT
  else
    if [[ "$1" ]]; then
      if [[ "$2" ]]; then
        rev="$2"
      fi

      if [[ -z "$1" ]]; then
        if [[ "$PROJECT" ]]; then
          if [[ "$bash_interactive" ]]; then
            exit
          else
            export PATH=$path_backup
            export PS1="$ps1_backup"
          fi
        fi
      else
        name=`basename $1`
        if [[ -d "$HOME/$name" ]]; then
          if [[ "$bash_interactive" ]]; then
            if [[ "$PROJECT" == "$name" ]]; then
                echo Error: already in $PROJECT...
                return
            fi

            oldpath=`pwd`
            cd $HOME/$name
            ci_pid=$!

            PROJECT=$name \
            PROJECT_DIR=$HOME/$PROJECT \
            APP_DIR=$PROJECT_DIR/app \
            HTML_DIR=$PROJECT_DIR/html \
            CONFIG_DIR=$PROJECT_DIR/env/etc \
            ENV_DIR=$PROJECT_DIR/env \
            PROJECT_ENV=$([[ -f $PROJECT_DIR/env/etc/environment ]] && cat $PROJECT_DIR/env/etc/environment || echo 'dev') \
            BIN_DIR=$PROJECT_DIR/env/bin \
            RUN_DIR=$PROJECT_DIR/env/run \
            LOG_DIR=$PROJECT_DIR/env/log \
            VAR_DIR=$PROJECT_DIR/env/var \
            TMP_DIR=$PROJECT_DIR/env/tmp \
            KISS_CORE=$PROJECT_DIR/app/core.php \
            HTTP_HOST=$(hostname) \
            PATH=$PROJECT_DIR:$PROJECT_DIR/env/bin:$path_backup \
            PS1=$PS1 \
            bash

            [[ ! -z $ci_pid ]] && kill $ci_pid
            cd $oldpath
          else

            export PROJECT=$name
            export PROJECT_DIR=$HOME/$PROJECT
            export APP_DIR=$PROJECT_DIR/app \
              HTML_DIR=$PROJECT_DIR/html \
              CONFIG_DIR=$PROJECT_DIR/env/etc \
              ENV_DIR=$PROJECT_DIR/env \
              PROJECT_ENV=$([[ -f $PROJECT_DIR/env/etc/environment ]] && cat $PROJECT_DIR/env/etc/environment || echo 'dev') \
              BIN_DIR=$PROJECT_DIR/env/bin \
              RUN_DIR=$PROJECT_DIR/env/run \
              LOG_DIR=$PROJECT_DIR/env/log \
              VAR_DIR=$PROJECT_DIR/env/var \
              TMP_DIR=$PROJECT_DIR/env/tmp \
              KISS_CORE=$PROJECT_DIR/app/core.php \
              HTTP_HOST=$(hostname) \
              PATH=$PROJECT_DIR:$PROJECT_DIR/env/bin:$path_backup
            cd ~/$PROJECT
          fi
        else
          echo "Error: project $name not found..."
        fi
      fi
    else
      echo "Error: project is not selected" 1
    fi
  fi
}

# App ini template configurator
# block, params
app_config() {
  if [[ -z $1 || -z $2 ]]; then
    echo 'Usage: app_config block params'
    return
  fi

  if [[ -z $PROJECT ]]; then
    echo 'Not in project. Run kiss PROJECT';
    return
  fi

  echo "
[$1]
$2
" >> $APP_DIR/config.ini.tpl
}

# Random password generator
# symbols, length
ssh_random_string() {
  symbols='A-Za-z0-9'
  if [[ -z $1 ]]; then
    symbols=$1
  fi

  length=40
  if [[ $2 =~ ^[0-9]+$ ]]; then
    length=$2
  fi

  < /dev/urandom tr -dc ${symbols} | head -c${length} && echo
}

# Allocate port for service
allocate_port() {
  if [[ -z $1 ]]; then
    echo 'Usage: allocate_port name'
    return
  fi
  [[ ! -f ~/ports ]] && touch ~/ports

  start=33000
  max=33000
  for line in `cat ~/ports`; do
    port=${line##*:}
    if (( $max < $port )); then
      max=$port
    fi
  done
  port=$(( $max + 1 ))

  line=$(cat ~/ports | grep -E ^$PROJECT:$1\:[0-9]+$)
  if [[ -z $line ]]; then
    echo "$PROJECT:$1:$port" >> ~/ports
    cat ~/ports | sort -h > ~/ports.tmp
    mv ~/ports.tmp ~/ports
  else
    port=${line##*:}
  fi
  echo $port
}

# Run checks using array checks
run_checks() {
  exit_code=0
  declare -A results

  for k in "${!checks[@]}"; do
    ${checks[$k]} &> /dev/null
    [[ "$?" != "0" ]] && results["$k"]='\e[1;31mFail' && exit_code=1 || results["$k"]='\e[1;32mSuccess'
  done

  for k in "${!results[@]}"; do
    echo -e "\e[1;34m$k\e[0m - ${results[$k]}\e[0m"
  done

  exit $exit_code
}


init() {
  [[ -z "$PROJECT" ]] && echo 'Not in project. Use "kiss PROJECT" first' && return;
  echo 'Initialization started'

  echo '+Configure and compile project'
  php_exec 'Env::init()'
  echo '...done'

  echo '+Reloading services'
  sudo systemctl reload nginx.service
  sudo systemctl reload php-fpm.service
  echo '...done'

  echo '+Running init-app script'
  [[ -x $BIN_DIR/init-app ]] && $BIN_DIR/init-app | xargs -0 -l echo '  '
  echo '...done'
}

php_exec() {
  [[ -z "$PROJECT" ]] && echo 'Not in project. Use "kiss PROJECT" first' && return;
  [[ -z "$1" ]] && echo 'Usage: php_exec [code | php_file]' && return
  php=$(which php)
  config=$($php --ini | head -n 1)
  config=${config##* }

  OPTS=''
  if [[ -f $config ]]; then
    OPTS='-c '$config
  fi
  code=$(test -f "$1" && echo "include '$1'" || echo "$1");
  $php $OPTS <<EOF
<?php
    include getenv('KISS_CORE');

    // Получаем ответ   и выполняем запрос
    try {
      App::start();
      $code;
      App::stop();
    } catch (Exception \$E) {
      echo 'Error: ' . \$E->getMessage() . PHP_EOL . 'More info: tail -f $LOG_DIR/' . date('Ymd') . '-error.log';
    }
EOF
  echo
}

install_plugin() {
  [[ -z "$PROJECT" ]] && echo 'Not in project. Use "kiss PROJECT" first' && return;
  if [[ -z "$1" ]]; then
    echo -e 'Usage: install_plugin plugin1 plugin2 plugin3'
    echo -e '- \e[35;1mPLUGIN_DIR\e[0;0m=/path/to/plugin   Specify dir with plugins that can be installed'
    echo -e '- \e[35;1mPLUGIN_UPDATE\e[0;0m=1              Update or skip during install. Default: 0'
    return
  fi
  if [[ -z $PLUGIN_DIR ]]; then
    PLUGIN_DIR=$PROJECT_DIR/plugin
  fi

  if [[ ! -d $PLUGIN_DIR ]]; then
    echo 'No plugin dir specified or plugin dir does not exist. Define plugin dir. Use export PLUGIN_DIR=/path/to/plugin'
    return
  fi

  for plugin in $@; do
    plugin_dir=$PLUGIN_DIR/$plugin
    if [[ ! -d $plugin_dir ]]; then
      echo 'Cant find plugin "'$plugin'" in plugin dir "'$PLUGIN_DIR'"'
      return
    fi
  done

  rebuild=0
  for plugin in $@; do
    _install_plugin $plugin
  done

  if (( $rebuild )); then
    echo -e '\e[32;1mStarting init script to realod maps\e[0;0m'
    kiss $PROJECT << "EOF"
      init
EOF
  fi
}

# internal method to call from install_plugin function
_install_plugin() {
  plugin=$1
  echo -e 'Trying install \e[34;1m'$plugin'\e[0;0m'
  plugin_dir=$PLUGIN_DIR/$plugin

  # Check requirements
  if [[ -x $plugin_dir/check ]]; then
    check_log=$TMP_DIR/plugin-checks-$plugin
    $plugin_dir/check > $check_log 2>&1
    if [[ $? -ne 0 ]]; then
      echo 'Run checks failed, skipping...'
      /bin/cat $check_log && /bin/rm $check_log
      continue
    fi
    /bin/rm $check_log
  fi

  install_to=$APP_DIR/plugin/$plugin
  if [[ -z $PLUGIN_UPDATE && -d $install_to ]]; then
    echo 'Plugin already installed, skipping. Use PLUGIN_UPDATE=1 for update'
    continue
  fi

  if [[ -d $install_to ]]; then
    echo 'Found old installation. Backuping...'
    /bin/tar -czf $install_to/$(/bin/date +%Y%m%d-%H%M%S).backup.tar.gz --exclude=*.backup.tar.gz $install_to/
    /usr/bin/find $install_to -type f -not -name '*.backup.tar.gz' | xargs /bin/rm
  fi

  /bin/mkdir -p $install_to
  /bin/cp -favr $plugin_dir/* $install_to

  [[ -x $install_to/setup ]] && $install_to/setup
  echo '...done'

  if [[ -f $install_to/require ]]; then
    for dep in `cat $install_to/require`; do
      _install_plugin "$dep"
    done
  fi
  rebuild=1
}

deploy() {
  [[ -z "$PROJECT" ]] && echo 'Not in project. Use "kiss PROJECT" first' && return;
  if [[ -z "$1" ]]; then
    echo 'Usage: deploy [all|production|test|...]' && return
  fi
  user='web'
  host_file=$CONFIG_DIR/hosts
  if [[ ! -f $host_file ]]; then
    echo 'Create hosts "'$host_file'" file with hostnames to deploy on'
    return
  fi

  if [[ "$1" == "all" ]]; then
    servers=$(cat $host_file)
  else
    servers=$(cat $host_file | grep $1)
  fi

  if [[ -z $servers ]]; then
    echo 'There are no servers for deploy "'$1'" in hosts file'
    return
  fi

  # Revision
  commit=$(git log -n 1 | grep commit | cut -d' ' -f2 2>/dev/null)
  revision=$(`which date` +%y%m%d%H%M)
  if [[ ! -z $commit ]]; then
    revision=$revision.${commit:0:7}
  fi

  # Deploy on each server
  for server in $servers; do
    echo $server
    (
    environment=${server#*:}
    if [[ "$environment" == "$server" || -z "$environment" ]]; then
      environment='production'
    fi
    server=${server%:*}

    echo 'Deploying on server '$server':'$environment
    scp $HOME/.kissrc $user@$server:/home/$user
    ssh -T $user@$server <<"EOF"
      /bin/cat $HOME/.bashrc | /bin/grep -v '#.kissrc$' > $HOME/.bashrc.tmp
      echo "source $HOME/.kissrc #.kissrc" >> $HOME/.bashrc.tmp
      /bin/mv $HOME/.bashrc.tmp $HOME/.bashrc
      source $HOME/.bashrc
EOF

    # Create dir if they do not exist
    ssh -T $user@$server "mkdir -p /home/$user/$PROJECT/rev/$revision && test -L /home/$user/$PROJECT/app && cp -r \$_/* /home/$user/$PROJECT/rev/$revision"

    # Create revision
    rsync -aiz --delete-before $APP_DIR/ $user@$server:/home/$user/$PROJECT/rev/$revision/

    # Compile PROJECT on server
    ssh -T $user@$server <<EOF
      test -L /home/$user/$PROJECT/app && rm -f \$_
      ln -s /home/$user/$PROJECT/rev/$revision /home/$user/$PROJECT/app

      mkdir -p /home/$user/$PROJECT/env/{etc,log,var,run,tmp,backup}

      test ! -L /home/$user/$PROJECT/html && ln -s /home/$user/$PROJECT/app/static \$_
      test ! -L /home/$user/$PROJECT/env/bin && ln -s /home/$user/$PROJECT/app/bin \$_

      kiss $PROJECT
      echo $environment > \$CONFIG_DIR/environment
      export PROJECT_ENV=$environment
      init
      [[ \$(/bin/ls \$TMP_DIR) ]] && /bin/rm \$TMP_DIR/*
      php_exec 'opcache_reset()' > /dev/null
EOF
    # All is done
    echo 'Deployed on server '$server
    ) > $TMP_DIR/deploy.$server 2>&1 &
  done
  wait $(jobs -rp) 2> /dev/null
  echo

  # Display result of jobs
  for file in $(ls $TMP_DIR/deploy.*); do
    cat $file
    rm $file
  done

  echo 'Executing deploy-done script...'
  test -x $BIN_DIR/deploy-done && $_
  echo 'Executing deploy-done script done'
}

export -f kiss ssh_random_string allocate_port run_checks app_config init deploy install_plugin php_exec
